! ---------------------------------------------------------------------------------------
! Converting a (meta-)GGA exchange energy density into a short-range meta-GGA functional
! ---------------------------------------------------------------------------------------
! The subroutine MODRZEJ2016_SR_X_EXACT_CURVATURE converts its input, a (meta-)GGA
! exchange energy density, into a meta-GGA short-range exchange energy functional.
! Even if the input is a GGA, the output is a meta-GGA which depends on the density,
! density gradient, Laplacian, and kinetic energy density. The generation
! of the short-range functional is composed of the following main steps:
!
! 1) A Becke-Roussel-type exchange hole with the exact second-order expansion in
!    interelectron distance is adjusted to recover the input exchange energy.
! 2) The Becke-Roussel-type exchange hole is integrated with the long-range potential
!    erf(omega*r)/r to compute the long-range exchange energy density.
! 3) The long-range component is subtracted from the base exchange energy density to get
!    the short-range component, which is the final output.
! 
!
module modrzej2016_x_energy
      use math_constants
      use arithmetic
      use chebinterp
      use modrzej2016_x_params

      implicit none

contains

      pure subroutine uxlrbr89(uxlr, uxlr_a, uxlr_b, a, b, omega)
            ! -----------------------------------------------------------------
            ! Compute the exchange potential generated by the long-range part
            ! of the Becke-Roussel exchange hole defined by the parameters
            ! a and b.
            !
            ! The electrostatic potential generated by the long-range
            ! BR exchange hole is defined as follows:
            ! 4*Pi * \int h_{BR}(a,b;s) * ERF(OMEGA*s) / s * s**2 ds =  
            ! U_{X\sigma}^{LR} = -omega/Y * ERF(Y) +
            !          omega/(2*Y) * (1-X**2+XY)*ERFC(X-Y)*EXP(X**2-2*X*Y) +
            !          omega/(2*Y) * (-1+X**2+XY)*ERFC(X+Y)*EXP(X**2+2*X*Y)
            !
            ! -----------------------------------------------------------------
            ! 1. Becke, A.D., Roussel, M.R., Exchange holes in inhomogeneous
            !    systems: A coordinate-space model, Phys. Rev. A, 39,
            !    3761(1989); doi: 10.1103/PhysRevA.39.3761
            ! -----------------------------------------------------------------
            ! A, B   
            !          Parameters of the Becke-Roussel exchange hole, see 
            !          Eq. 17 in [1]
            ! OMEGA  
            !          The range separation parameter of the ERF function,
            ! UXLR   
            !          Exchange potential generated by long-range part of BR
            !          hole
            ! UXLR_A 
            !          Partial derivative: dUXLR/dA
            ! UXLR_B 
            !          Partial derivative: dUXLR/dB
            !
            real(F64), intent(out) :: uxlr
            real(F64), intent(out) :: uxlr_a
            real(F64), intent(out) :: uxlr_b
            real(F64), intent(in)  :: a
            real(F64), intent(in)  :: b
            real(F64), intent(in)  :: omega

            real(F64) :: x, x_a, y, y_b, uxlr_x, uxlr_y

            x = a / (TWO * omega)
            x_a = ONE / (TWO * omega)
            y = b * omega
            y_b = omega
            !
            ! See the comments for UXLRBR89_SMALLY for the information
            ! on the number of significant digits as a function of Y
            !
            if (y <= 0.334_F64) then
                  call uxlrbr89_smally(uxlr, uxlr_x, uxlr_y, x, y, omega)
            else
                  call uxlrbr89_generaly(uxlr, uxlr_x, uxlr_y, x, y, omega)
            end if

            uxlr_a = uxlr_x * x_a
            uxlr_b = uxlr_y * y_b
      end subroutine uxlrbr89


      subroutine modrzej2016_sr_x_exact_curvature(sr_eps, sr_rho, sr_sig, sr_lap, sr_tau, rho, sigma, lapl, tau, &
            fr_eps, fr_rho, fr_sig, fr_lap, fr_tau, omega)
            ! ------------------------------------------------------------------------------------
            ! Compute the short-range part of an arbitrary exchange energy density. The meta-GGA
            ! ingredients, rho, sigma, lapl, and tau, are employed to get the exact second-order
            ! expansion of the underlying exchange hole, so the resulting short-range functional
            ! is always a meta-GGA, regardless of the rung of the base exchange energy.
            ! ------------------------------------------------------------------------------------
            ! SR_EPS
            !           Short-range exchange energy density. Short-range exchange energy:
            !           ExSR = rho * sr_eps
            ! SR_RHO, SR_SIG, SR_LAP, SR_TAU
            !           Derivatives of ExSR: dExSR/dRho, dExSR/dSigma, dExSR/dLapl, dExSR/dTau
            ! RHO
            !           Total electron density (alpha+beta spin contributions)
            !           of a closed-shell system          
            ! SIGMA
            !           Density gradient = (Nabla RHO) * (Nabla RHO)
            ! LAPL
            !           Density Laplacian = Nabla^2 RHO
            ! TAU
            !           Kinetic energy density = 2 * SUM_i (Nabla Phi_i) * (Nabla Phi_i), where 
            !           the summation is over occupied orbitals. Note that the definition of TAU
            !           does not include the 1/2 factor which some authors use.
            ! FR_EPS
            !           Exchange energy density of the base full-range exchange functional.
            !           Full-range exchange energy: ExFR = FR_EPS * RHO
            ! FR_RHO, FR_SIG, FR_LAP, FR_TAU
            !           Derivatives of ExFR: dExFR/dRho, dExFR/dSigma, dExFR/dLapl, dExFR/dTau
            !           If the base functional does not depend on tau and/or lapl,
            !           the corresponding derivatives should be set to zero.
            ! OMEGA
            !           Range-separation parameter of the long-range potential erf(omega * r) / r
            !
            real(F64), intent(out) :: sr_eps
            real(F64), intent(out) :: sr_rho
            real(F64), intent(out) :: sr_sig
            real(F64), intent(out) :: sr_lap
            real(F64), intent(out) :: sr_tau
            real(F64), intent(in)  :: rho
            real(F64), intent(in)  :: sigma
            real(F64), intent(in)  :: lapl
            real(F64), intent(in)  :: tau
            real(F64), intent(in)  :: fr_eps
            real(F64), intent(in)  :: fr_rho
            real(F64), intent(in)  :: fr_sig
            real(F64), intent(in)  :: fr_lap
            real(F64), intent(in)  :: fr_tau
            real(F64), intent(in)  :: omega

            real(F64) :: Q, Q_rho, Q_sig, Q_lap, Q_tau
            real(F64) :: rhs, rhs_rho, rhs_sig, rhs_lap, rhs_tau
            real(F64) :: a, a_rho, a_sig, a_lap, a_tau, b, b_rho, b_sig, b_lap, b_tau
            real(F64) :: a2, a2_rho, a2_sig, a2_lap, a2_tau, a2_x, a2_eps
            real(F64) :: x, x_rhs, x_rho, x_sig, x_lap, x_tau, expx, N, N_rho, N_sig, N_lap, N_tau, N_x, N_a
            real(F64) :: lr_e, ux, ux_a, ux_b, lr_a, lr_b, lr_eps, lr_rho, lr_sig, lr_lap, lr_tau
            real(F64) :: eps, eps_rho, eps_sig, eps_lap, eps_tau
            logical :: converged
            real(F64), parameter :: convthresh = 1.0E-14_F64
            !
            ! fr_rho = d(rho*fr_eps)/drho = fr_eps + rho * dfr_eps/drho
            ! (fr_rho - fr_eps) / rho = dfr_eps/drho
            !
            eps = fr_eps
            eps_rho = (fr_rho - fr_eps) / rho
            eps_sig = fr_sig / rho
            eps_lap = fr_lap / rho
            eps_tau = fr_tau / rho
            !
            ! Compute the second-order term of the expansion
            ! hx(r, s) = 1/2 rho - Q * s**2 + ...
            !
            Q = (1.0_F64/12.0_F64) * lapl - (1.0_F64/6.0_F64) * tau + (1.0_F64/24.0_F64) * sigma / rho
            Q_rho = -(1.0_F64/24.0_F64) * sigma / rho**2
            Q_sig = (1.0_F64/24.0_F64) / rho
            Q_lap = 1.0_F64/12.0_F64
            Q_tau = -1.0_F64/6.0_F64
            
            rhs = -6.0_F64/PI * Q / rho**2 * eps
            rhs_rho = -6.0_F64/PI / rho**2 * (Q_rho * eps + Q * eps_rho - 2.0_F64 * Q * eps / rho)
            rhs_sig = -6.0_F64/PI / rho**2 * (Q_sig * eps + Q * eps_sig)
            rhs_lap = -6.0_F64/PI / rho**2 * (Q_lap * eps + Q * eps_lap)
            rhs_tau = -6.0_F64/PI / rho**2 * (Q_tau * eps + Q * eps_tau)
            !
            ! Find the parameter x of the Becke-Roussel hole (Eq. A7 in Ref. 1)
            !
            call x_solver_exact_curvature(x, x_rhs, rhs, converged, convthresh)
            x_rho = x_rhs * rhs_rho
            x_sig = x_rhs * rhs_sig
            x_lap = x_rhs * rhs_lap
            x_tau = x_rhs * rhs_tau
            !
            ! Compute a**2 by solving Eq. A4 for a**2. This method is more numerically
            ! stable than Eq. A6. (The numerical stability tested with Mathematica for
            ! Qs close to zero.)
            !
            expx = exp(x)
            a2 = PI * rho * (TWO - TWO * expx + x) / (x * eps)
            a2_x = -TWO*PI * rho * (ONE + expx * (x - ONE)) / (x**2 * eps)
            a2_eps = -PI * rho * (TWO - TWO * expx + x) / (x * eps**2)
            a2_rho = PI * (TWO - TWO * expx + x) / (x * eps) + a2_x * x_rho + a2_eps * eps_rho
            a2_sig = a2_x * x_sig + a2_eps * eps_sig
            a2_lap = a2_x * x_lap + a2_eps * eps_lap
            a2_tau = a2_x * x_tau + a2_eps * eps_tau
                  
            a = sqrt(a2)
            a_rho = (ONE/TWO) / a * a2_rho
            a_sig = (ONE/TWO) / a * a2_sig
            a_lap = (ONE/TWO) / a * a2_lap
            a_tau = (ONE/TWO) / a * a2_tau

            b = x / a
            b_rho = x_rho / a - b / a * a_rho
            b_sig = x_sig / a - b / a * a_sig
            b_lap = x_lap / a - b / a * a_lap
            b_tau = x_tau / a - b / a * a_tau
            !
            ! Normalization factor (Eq. A8 in Ref. 1)
            !
            N = FOUR*PI * rho * expx / a**3
            N_x = N
            N_a = -THREE * N / a
            N_rho = FOUR*PI * expx / a**3 + N_x * x_rho + N_a * a_rho
            N_sig = N_x * x_sig + N_a * a_sig
            N_lap = N_x * x_lap + N_a * a_lap
            N_tau = N_x * x_tau + N_a * a_tau
            !
            ! Compute the Coulomb potential generated by the sigma-spin long-range
            ! normalized Becke-Roussel exchange hole. The exchange hole potential and its
            ! derivatives are divided by two so that the final energy density
            ! and the derivatives correspond to the spin-compensated equations:
            ! Ex = 2 * 1/2 * int rho_sigma * U_sigma
            ! = int rho/2 * U_sigma = int rho * U_sigma/2 => eps = U_sigma/2
            ! Note that Ux is computed for the BR hole normalized to -1 and needs
            ! rescaling.
            !
            call uxlrbr89(ux, ux_a, ux_b, a, b, omega)
            lr_e = ux / TWO * rho
            lr_eps = ux / TWO
            lr_a = rho * ux_a / TWO
            lr_b = rho * ux_b / TWO
            lr_rho = lr_eps + lr_a * a_rho + lr_b * b_rho
            lr_sig = lr_a * a_sig + lr_b * b_sig
            lr_lap = lr_a * a_lap + lr_b * b_lap
            lr_tau = lr_a * a_tau + lr_b * b_tau
            !
            ! Ux has been computed for the hole without the normalization factor N. Use the normalization
            ! factor to rescale the integral
            !
            lr_eps = N * lr_eps
            lr_rho = N_rho * lr_e + N * lr_rho
            lr_sig = N_sig * lr_e + N * lr_sig
            lr_lap = N_lap * lr_e + N * lr_lap
            lr_tau = N_tau * lr_e + N * lr_tau
            !
            ! Compute the short-range exchange energy by subtracting the long-range term
            !
            sr_eps = fr_eps - lr_eps
            sr_rho = fr_rho - lr_rho
            sr_sig = fr_sig - lr_sig
            sr_lap = fr_lap - lr_lap
            sr_tau = fr_tau - lr_tau
      end subroutine modrzej2016_sr_x_exact_curvature


      pure subroutine x_solver_exact_curvature(x, x_rhs, rhs, converged, convthresh)
            real(F64), intent(out) :: x
            real(F64), intent(out) :: x_rhs
            real(F64), intent(in)  :: rhs
            logical, intent(out)   :: converged
            real(F64), intent(in)  :: convthresh

            real(F64) :: xleft, xright, xmiddle
            real(F64) :: lhs_middle, lhs_middle_x
            real(F64) :: lhs_right, lhs_right_x
            integer :: k
            integer, parameter :: maxiter = 1000
            !
            ! The upper bound on the value of X:
            ! LHS(max_x) = 1.4447E+301
            ! dLHS/dx(max_x) = 1.4427E+301
            ! Max_x is used to avoid infinities. Both LHS(max_x) and
            ! dLHS/dx(max_x) are smaller than the maximum representable
            ! 64-bit number in the IEEE 754-1985 arithmetic.
            !
            real(F64), parameter :: max_x = 700.0_F64
            
            if (rhs < ZERO) then
                  xleft = 0.0_F64
                  xright = 2.0_F64
            else
                  xleft = 2.0_F64
                  xright = 4.0_F64
                  call lhs_exact_curvature(lhs_right, lhs_right_x, xright)
                  do while (lhs_right <= rhs .and. xright < max_x)
                        xright = xright + 5.0_F64
                        call lhs_exact_curvature(lhs_right, lhs_right_x, xright)
                  end do
            end if

            converged = .false.
            do k = 1, maxiter
                  xmiddle = (xleft + xright) / TWO
                  call lhs_exact_curvature(lhs_middle, lhs_middle_x, xmiddle)
                  if (lhs_middle < rhs) then
                        xleft = xmiddle
                  else
                        xright = xmiddle
                  end if

                  xmiddle = (xleft + xright) / TWO
                  if (abs(xleft - xright) < abs(convthresh * xmiddle)) then
                        converged = .true.
                        call lhs_exact_curvature(lhs_middle, lhs_middle_x, xmiddle)
                        exit
                  end if
            end do
            !
            ! LHS(x) = RHS
            ! dLHS(x)/dx * dx/dRHS = 1 => dx/dRHS = 1/(dLHS(x)/dx)
            !
            x = xmiddle
            x_rhs = ONE/lhs_middle_x
      end subroutine x_solver_exact_curvature


      pure subroutine lhs_exact_curvature(lhs, lhs_x, x)
            real(F64), intent(out) :: lhs
            real(F64), intent(out) :: lhs_x
            real(F64), intent(in)  :: x

            real(F64), dimension(9), parameter :: c = &
                  [-1.0_F64/2.0_F64, 1.0_F64/6.0_F64, &
                  1.0_F64/12.0_F64, 1.0_F64/40.0_F64, &
                  1.0_F64/180.0_F64, 1.0_F64/1008.0_F64, &
                  1.0_F64/6720.0_F64, 1.0_F64/51840.0_F64, &
                  1.0_F64/453600.0_F64]
            real(F64), dimension(9), parameter :: cx = &
                  [1.0_F64/6.0_F64, 1.0_F64/6.0_F64, &
                  3.0_F64/40.0_F64, 1.0_F64/45.0_F64, &
                  5.0_F64/1008.0_F64, 1.0_F64/1120.0_F64, &
                  7.0_F64/51840.0_F64, 1.0_F64/56700.0_F64, &
                  1.0_F64/492800.0_F64]
            real(F64), parameter :: x0 = 0.1_F64
            real(F64) :: expx

            if (x < x0) then
                  lhs = -1.0_F64/x + c(1) + c(2)*x + c(3)*x**2 + c(4)*x**3 + c(5)*x**4 &
                        + c(6)*x**5 + c(7)*x**6 + c(8)*x**7 + c(9)*x**8
                  lhs_x = 1.0_F64/x**2 + cx(1) + cx(2)*x + cx(3)*x**2 + cx(4)*x**3 + cx(5)*x**4 &
                        + cx(6)*x**5 + cx(7)*x**6 + cx(8)*x**7 + cx(9)*x**8
            else
                  expx = exp(x)
                  lhs = (x - TWO) / x**2 * (expx - ONE - x / TWO)
                  lhs_x = (expx * (FOUR - THREE * x + x**2) - FOUR) / x**3
            end if
      end subroutine lhs_exact_curvature


      pure subroutine uxlrbr89_smally(uxlr, uxlr_x, uxlr_y, x, y, omega)
            !
            ! Compute the Coulomb potential Uxs generated by the Becke-Roussel
            ! exchange hole interacting via the erf(omega * r) / r potential.
            ! This subroutine handles the small y case (y=b*omega). The 16th
            ! order Taylor approximation in y guarantees the following error
            ! bounds for x=10:
            !
            !                     A          B         C  
            ! Z                   d(Z)       d(Z)      d(Z)
            ! uxlr(x,y,omega)     d > 16.5   d > 15.4    d > 14.3
            ! uxlr_x(x,y,omega)   d > 15.2   d > 14.1    d > 13.0
            ! uxlr_y(x,y,omega)   d > 14.0   d > 13.0    d > 12.0
            !
            ! A 0 <= y <= 0.290
            ! B 0 <= y <= 0.334
            ! C 0 <= y <= 0.385
            !
            ! where d(Z) = -Log10(Abs((Z_approx-Z_exact)/Z_exact)).
            ! The x-dependent coefficients (x=a/(2*omega)) of the Taylor
            ! expansion are computed via 1) the Chebyshev interpolation
            ! for 0.0 < x <= 6.0; 2) Pade approximants for 6.0 < x < Infinity.
            !
            ! The relative errors for small x are larger than the ones presented
            ! in the above table, especially for uxlr_y. However, the deterioration of
            ! accuracy is not observed for x > 0.1. Note that uxlr_y is very
            ! small for small x. 
            !
            real(F64), intent(out) :: uxlr
            real(F64), intent(out) :: uxlr_x
            real(F64), intent(out) :: uxlr_y
            real(F64), intent(in)  :: x
            real(F64), intent(in)  :: y
            real(F64), intent(in)  :: omega
            
            if (x <= w_interp_b_0) then
                  call uxlrbr89_smally_smallx(uxlr, uxlr_x, uxlr_y, x, y, omega, &
                        w16_coeffs_0, w14_coeffs_0, w12_coeffs_0, w10_coeffs_0, w8_coeffs_0, &
                        w6_coeffs_0, w4_coeffs_0, w2_coeffs_0, w0_coeffs_0, w16x_coeffs_0, &
                        w14x_coeffs_0, w12x_coeffs_0, w10x_coeffs_0, w8x_coeffs_0, w6x_coeffs_0, &
                        w4x_coeffs_0, w2x_coeffs_0, w0x_coeffs_0, w_interp_a_0, w_interp_b_0)

            else if (x <= w_interp_b_1) then
                  call uxlrbr89_smally_smallx(uxlr, uxlr_x, uxlr_y, x, y, omega, &
                        w16_coeffs_1, w14_coeffs_1, w12_coeffs_1, w10_coeffs_1, w8_coeffs_1, &
                        w6_coeffs_1, w4_coeffs_1, w2_coeffs_1, w0_coeffs_1, w16x_coeffs_1, &
                        w14x_coeffs_1, w12x_coeffs_1, w10x_coeffs_1, w8x_coeffs_1, w6x_coeffs_1, &
                        w4x_coeffs_1, w2x_coeffs_1, w0x_coeffs_1, w_interp_a_1, w_interp_b_1)

            else if (x <= w_interp_b_2) then
                  call uxlrbr89_smally_smallx(uxlr, uxlr_x, uxlr_y, x, y, omega, &
                        w16_coeffs_2, w14_coeffs_2, w12_coeffs_2, w10_coeffs_2, w8_coeffs_2, &
                        w6_coeffs_2, w4_coeffs_2, w2_coeffs_2, w0_coeffs_2, w16x_coeffs_2, &
                        w14x_coeffs_2, w12x_coeffs_2, w10x_coeffs_2, w8x_coeffs_2, w6x_coeffs_2, &
                        w4x_coeffs_2, w2x_coeffs_2, w0x_coeffs_2, w_interp_a_2, w_interp_b_2)
            else
                  call uxlrbr89_smally_largex(uxlr, uxlr_x, uxlr_y, x, y, omega)
            end if
      end subroutine uxlrbr89_smally
      

      pure subroutine uxlrbr89_smally_smallx(uxlr, uxlr_x, uxlr_y, x, y, omega, &
            w16, w14, w12, w10, w8, w6, w4, w2, w0, w16x, w14x, w12x, w10x, &
            w8x, w6x, w4x, w2x, w0x, a, b)
            !
            ! Numerically stable evaluation of UxsBR(x, y, omega) for small y and small/moderate x.
            ! UxsBR(x, y, omega) = omega * (w0 + w2 * y**2 + w4 * y**4 + ... + w16 * y**16)
            ! dUxsBR(x, y, omega)/dx = omega * (wx0 + wx2 * y**2 + wx4 * y**4 + ... + wx16 * y**16)
            ! wk's and wxk's are evaluated using Chebyshev interpolation.
            !
            real(F64), intent(out) :: uxlr
            real(F64), intent(out) :: uxlr_x
            real(F64), intent(out) :: uxlr_y
            real(F64), intent(in)  :: x
            real(F64), intent(in)  :: y
            real(F64), intent(in)  :: omega
            real(F64), dimension(w_interp_n), intent(in) :: w16, w14, w12, w10, w8, &
                  w6, w4, w2, w0
            real(F64), dimension(w_interp_n), intent(in) :: w16x, w14x, w12x, w10x, &
                  w8x, w6x, w4x, w2x, w0x
            real(F64), intent(in)  :: a
            real(F64), intent(in)  :: b

            real(F64) :: absum, abdiff, y2
            real(F64), dimension(w_interp_n) :: uxlr_vec, uxlr_x_vec, uxlr_y_vec

            y2 = y**2
            !
            ! Interchange the order of summation: first compute the polynomial
            ! in y using vectors of Chebyshev coefficients
            !
            uxlr_vec = w16
            uxlr_vec = w14 + y2 * uxlr_vec
            uxlr_vec = w12 + y2 * uxlr_vec
            uxlr_vec = w10 + y2 * uxlr_vec
            uxlr_vec = w8 + y2 * uxlr_vec
            uxlr_vec = w6 + y2 * uxlr_vec
            uxlr_vec = w4 + y2 * uxlr_vec
            uxlr_vec = w2 + y2 * uxlr_vec
            uxlr_vec = w0 + y2 * uxlr_vec

            uxlr_x_vec = w16x
            uxlr_x_vec = w14x + y2 * uxlr_x_vec
            uxlr_x_vec = w12x + y2 * uxlr_x_vec
            uxlr_x_vec = w10x + y2 * uxlr_x_vec
            uxlr_x_vec = w8x + y2 * uxlr_x_vec
            uxlr_x_vec = w6x + y2 * uxlr_x_vec
            uxlr_x_vec = w4x + y2 * uxlr_x_vec
            uxlr_x_vec = w2x + y2 * uxlr_x_vec
            uxlr_x_vec = w0x + y2 * uxlr_x_vec

            uxlr_y_vec = 16.0_F64 * w16
            uxlr_y_vec = 14.0_F64 * w14 + y2 * uxlr_y_vec
            uxlr_y_vec = 12.0_F64 * w12 + y2 * uxlr_y_vec
            uxlr_y_vec = 10.0_F64 * w10 + y2 * uxlr_y_vec
            uxlr_y_vec = 8.0_F64 * w8 + y2 * uxlr_y_vec
            uxlr_y_vec = 6.0_F64 * w6 + y2 * uxlr_y_vec
            uxlr_y_vec = 4.0_F64 * w4 + y2 * uxlr_y_vec
            uxlr_y_vec = 2.0_F64 * w2 + y2 * uxlr_y_vec
            uxlr_y_vec = y * uxlr_y_vec

            absum = a + b
            abdiff = b - a

            call cheb_approx_n(uxlr, x, uxlr_vec, w_interp_n, absum, abdiff)
            call cheb_approx_n(uxlr_x, x, uxlr_x_vec, w_interp_n, absum, abdiff)
            call cheb_approx_n(uxlr_y, x, uxlr_y_vec, w_interp_n, absum, abdiff)
            uxlr = uxlr * omega
            uxlr_x = uxlr_x * omega
            uxlr_y = uxlr_y * omega
      end subroutine uxlrbr89_smally_smallx
      

      pure subroutine uxlrbr89_smally_largex(uxlr, uxlr_x, uxlr_y, x, y, omega)
            !
            ! Numerically stable evaluation of UxsBR(x, y, omega) for small y and large x:
            !
            ! UxsBR(x, y, omega) = omega * (w0 + w2 * y**2 + w4 * y**4 + ... + w16 * y**16)
            ! wk = (rk0 + rk2 / x**2 + rk4 / x**4 + ... + rk14 / x**14) / (sk0 + sk2 / x**2 + sk4 / x**4 + ... + sk14 / x**14)
            !
            ! dUxsBR(x, y, omega)/dx = omega * (wx0 + wx2 * y**2 + wx4 * y**4 + ... + wx16 * y**16)
            ! dwk/dx = (tk3 / x**3 + tk5 / x**5 + ... + tk15 / x**15) / (uk0 + uk2 / x**2 + uk4 / x**5 + ... + uk14 / x**14)
            !
            ! The Pade approximants are computed by performing basic arithmetic operations
            ! on the vectors of coefficients rkl, skl, tkl, and ukl.
            !
            real(F64), intent(out) :: uxlr
            real(F64), intent(out) :: uxlr_x
            real(F64), intent(out) :: uxlr_y
            real(F64), intent(in)  :: x
            real(F64), intent(in)  :: y
            real(F64), intent(in)  :: omega
            
            real(F64), dimension(7) :: w_x
            real(F64), dimension(8) :: w, w_y
            real(F64), dimension(9) :: t
            real(F64) :: invx2, y2
            integer :: k

            invx2 = ONE / x**2
            y2 = y**2
            !
            ! The Pade coefficients gathered in the w_s_k vectors are used to compute
            ! all denominators at once in a vector operation:
            ! t = sum_l skl / x**l,
            ! where the resulting vector S contains the denominators of the Pade
            ! approximants for w16, w15, ..., w0.
            !
            t = invx2 * w_s_14
            t = invx2 * (w_s_12 + t)
            t = invx2 * (w_s_10 + t)
            t = invx2 * (w_s_8 + t)
            t = invx2 * (w_s_6 + t)
            t = invx2 * (w_s_4 + t)
            t = invx2 * (w_s_2 + t)
            t = w_s_0 + t
            !
            ! Now we accumulate the vectors representing the numerators of the Pade approximants:
            ! w = sum_k rkl * y**k / (sum_q skq / x**q) = sum_k rkl * y**l / tk
            !
            do k = 1, 9
                  t(k) = ONE / t(k)
            end do

            w = w16_pade_r * t(1)
            w = w14_pade_r * t(2) + y2 * w
            w = w12_pade_r * t(3) + y2 * w
            w = w10_pade_r * t(4) + y2 * w
            w = w8_pade_r * t(5) + y2 * w
            w = w6_pade_r * t(6) + y2 * w
            w = w4_pade_r * t(7) + y2 * w
            w = w2_pade_r * t(8) + y2 * w
            w = w0_pade_r * t(9) + y2 * w

            w_y = 16.0_F64 * t(1) * w16_pade_r
            w_y = 14.0_F64 * t(2) * w14_pade_r + y2 * w_y
            w_y = 12.0_F64 * t(3) * w12_pade_r + y2 * w_y
            w_y = 10.0_F64 * t(4) * w10_pade_r + y2 * w_y
            w_y = 8.0_F64 * t(5) * w8_pade_r + y2 * w_y
            w_y = 6.0_F64 * t(6) * w6_pade_r + y2 * w_y
            w_y = 4.0_F64 * t(7) * w4_pade_r + y2 * w_y
            w_y = 2.0_F64 * t(8) * w2_pade_r + y2 * w_y
            w_y = w_y * y

            t = invx2 * w_u_14
            t = invx2 * (w_u_12 + t)
            t = invx2 * (w_u_10 + t)
            t = invx2 * (w_u_8 + t)
            t = invx2 * (w_u_6 + t)
            t = invx2 * (w_u_4 + t)
            t = invx2 * (w_u_2 + t)
            t = w_u_0 + t

            do k = 1, 9
                  t(k) = ONE / t(k)
            end do

            w_x = w16_pade_t * t(1)
            w_x = w14_pade_t * t(2) + y2 * w_x
            w_x = w12_pade_t * t(3) + y2 * w_x
            w_x = w10_pade_t * t(4) + y2 * w_x
            w_x = w8_pade_t * t(5) + y2 * w_x
            w_x = w6_pade_t * t(6) + y2 * w_x
            w_x = w4_pade_t * t(7) + y2 * w_x
            w_x = w2_pade_t * t(8) + y2 * w_x
            w_x = w0_pade_t * t(9) + y2 * w_x
            !
            ! Finally, we use the vector w to compute the approximation for UxsBR:
            ! UxsBR = sum_l wl / x**l
            !
            uxlr = w(1)
            uxlr = w(2) + invx2 * uxlr
            uxlr = w(3) + invx2 * uxlr
            uxlr = w(4) + invx2 * uxlr
            uxlr = w(5) + invx2 * uxlr
            uxlr = w(6) + invx2 * uxlr
            uxlr = w(7) + invx2 * uxlr
            uxlr = omega * (w(8) + invx2 * uxlr)

            uxlr_y = w_y(1)
            uxlr_y = w_y(2) + invx2 * uxlr_y
            uxlr_y = w_y(3) + invx2 * uxlr_y
            uxlr_y = w_y(4) + invx2 * uxlr_y
            uxlr_y = w_y(5) + invx2 * uxlr_y
            uxlr_y = w_y(6) + invx2 * uxlr_y
            uxlr_y = w_y(7) + invx2 * uxlr_y
            uxlr_y = omega * (w_y(8) + invx2 * uxlr_y)

            uxlr_x = w_x(1)
            uxlr_x = w_x(2) + invx2 * uxlr_x
            uxlr_x = w_x(3) + invx2 * uxlr_x
            uxlr_x = w_x(4) + invx2 * uxlr_x
            uxlr_x = w_x(5) + invx2 * uxlr_x
            uxlr_x = w_x(6) + invx2 * uxlr_x
            uxlr_x = w_x(7) + invx2 * uxlr_x
            uxlr_x = omega / x * invx2 * uxlr_x
      end subroutine uxlrbr89_smally_largex


      pure subroutine uxlrbr89_generaly(uxlr, uxlr_x, uxlr_y, x, y, omega)
            real(F64), intent(out) :: uxlr
            real(F64), intent(out) :: uxlr_x
            real(F64), intent(out) :: uxlr_y
            real(F64), intent(in)  :: x
            real(F64), intent(in)  :: y
            real(F64), intent(in)  :: omega

            real(F64) :: term1, term1_y, erf_y, exp_my2
            real(F64) :: term2, term2_x, term2_y
            real(F64) :: term3, term3_x, term3_y
            real(F64) :: x2, y2, xy, ff
            real(F64) :: exp_t3_x, exp_t3_y, exp_t3
            real(F64) :: prefac, prefac_y
            real(F64) :: prefac2, prefac2_x, prefac2_y
            real(F64) :: erfc_xmy
            real(F64) :: poly1, poly1_x, poly1_y
            real(F64) :: poly2, poly2_x, poly2_y
            real(F64) :: v1, v1_t, v2, v2_t, t1, t2
            real(F64) :: t3, t3_x, t3_y

            x2 = x**2
            y2 = y**2
            xy = x * y
            exp_my2 = exp(-y2)
            erf_y = erf(y)
            term1 = -omega * erf_y / y
            term1_y = -TWO * omega / (PI12 * y) * exp_my2 - term1 / y
            prefac = omega / (TWO * y) * exp_my2
            prefac_y = -prefac / y - TWO * y * prefac
            poly1 = ONE - x2 + xy
            poly1_x = -TWO * x + y
            poly1_y = x
            poly2 = -ONE + x2 + xy
            poly2_x = TWO * x + y
            poly2_y = x
            t1 = x - y
            t2 = x + y
            if (t1 > ZERO) then
                  !
                  ! The subroutine ERFC_X_EXP_X2 is designed to handle
                  ! the case of a large, positive X, ERFC(X) * EXP(X**2), X >> 0
                  !
                  call erfc_x_exp_x2(t1, v1, v1_t)
                  term2 = prefac * poly1 * v1 
                  term2_x = prefac * (poly1_x * v1 + poly1 * v1_t)
                  term2_y = prefac_y * poly1 * v1 + prefac * (poly1_y * v1 - poly1 * v1_t)
            else
                  !
                  ! Different strategy must be taken if 
                  ! T1 << 0. In this case, the ERFCEXP
                  ! subroutine would try to evaluate
                  ! ERFC(-|X-Y|) * EXP((X-Y)**2), which goes
                  ! to infinity. Instead, we evaluate
                  ! omega/(2*Y) * ERFC(X-Y) * EXP(X**2-2*X*Y)
                  ! * (1-X**2+X*Y)
                  !
                  t3 = x2 - TWO * xy
                  t3_x = TWO * (x - y)
                  t3_y = -TWO * x
                  erfc_xmy = erfc(t1)
                  !
                  ! EXP(T3) function should be
                  ! close to ZERO whenever T1<<0
                  ! (large Y)
                  !
                  exp_t3 = exp(t3)
                  exp_t3_x = exp_t3 * t3_x
                  exp_t3_y = exp_t3 * t3_y
                  ff = omega / (TWO * y)
                  prefac2 = poly1 * ff
                  prefac2_x = poly1_x * ff
                  prefac2_y = poly1_y * ff - prefac2 / y
                  term2 = erfc_xmy * exp_t3 * prefac2
                  term2_x = (-TWO / PI12 * exp_my2 + erfc_xmy * exp_t3_x) * prefac2 &
                        + erfc_xmy * exp_t3 * prefac2_x
                  term2_y = (TWO / PI12 * exp_my2 + erfc_xmy * exp_t3_y) * prefac2 &
                        + erfc_xmy * exp_t3 * prefac2_y
            end if

            call erfc_x_exp_x2(t2, v2, v2_t)
            term3 = prefac * poly2 * v2
            term3_x = prefac * (poly2_x * v2 + poly2 * v2_t)
            term3_y = prefac_y * poly2 * v2 + prefac * (poly2_y * v2 + poly2 * v2_t)

            uxlr = term1 + term2 + term3
            uxlr_x = term2_x + term3_x
            uxlr_y = term1_y + term2_y + term3_y
      end subroutine uxlrbr89_generaly

      
      pure subroutine erfc_x_exp_x2(x, v, v_x)
            !
            ! V = ERFC(X) * EXP(X**2)
            ! V_X = d/dX (ERFC(X) * EXP(X**2))
            ! 
            real(F64), intent(in)  :: x
            real(F64), intent(out) :: v
            real(F64), intent(out) :: v_x

            real(F64) :: erfc_x, exp_x2, x2
            real(F64) :: s, s2, a, b
            real(F64) :: t1, t2, t3, t4, t5
            !
            ! For X >= 6.0 relative error of the Pade
            ! approximant is below 4.d-15
            !
            real(F64), parameter :: x0 = 6.0d+0
            real(F64), parameter :: a11 = 629.1595402781776d+0
            real(F64), parameter :: a09 = 1469.890174386764d+0
            real(F64), parameter :: a07 = 885.6365987740904d+0
            real(F64), parameter :: a05 = 200.5693969512274d+0
            real(F64), parameter :: a03 = 18.33616146530208d+0
            real(F64), parameter :: a01 = 0.5641895835477563d+0
            real(F64), parameter :: b00 = 1.000000000000000d+0
            real(F64), parameter :: b12 = 162.4218750000000d+0
            real(F64), parameter :: b10 = 1949.062500000000d+0
            real(F64), parameter :: b08 = 3248.437500000000d+0
            real(F64), parameter :: b06 = 1732.500000000000d+0
            real(F64), parameter :: b04 = 371.2500000000000d+0
            real(F64), parameter :: b02 = 33.00000000000000d+0
            
            if (x < x0) then
                  x2 = x**2
                  erfc_x = erfc(x)
                  exp_x2 = exp(x2)
                  v = erfc_x * exp_x2
            else
                  !
                  ! For X >= 6.0 relative error of the Pade
                  ! approximant is below 4.d-15
                  !
                  s = ONE / x
                  s2 = s**2
                  
                  t1 = a09 + s2 * a11
                  t2 = a07 + s2 * t1
                  t3 = a05 + s2 * t2
                  t4 = a03 + s2 * t3
                  t5 = a01 + s2 * t4
                  a = s * t5

                  t1 = b10 + s2 * b12
                  t2 = b08 + s2 * t1
                  t3 = b06 + s2 * t2
                  t4 = b04 + s2 * t3
                  t5 = b02 + s2 * t4
                  b = b00 + s2 * t5
                  
                  v = a / b
            end if
            !
            ! Derivative is calculated from the definition for both
            ! x < x0 and x > x0 to avoid degradation of accuracy
            ! resulting from differentiation of the Pade approximant
            !
            v_x = -TWO / PI12 + TWO * x * v
      end subroutine erfc_x_exp_x2
end module modrzej2016_x_energy
